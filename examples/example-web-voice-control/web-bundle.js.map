{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/point.ts","webpack:///./src/maze.ts","webpack:///./src/web-bundle.ts","webpack:///./src/generators/backtracking.ts","webpack:///./src/renderers/canvas.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Point","x","y","this","Maze","width","height","reInit","field","genEmptyField","startPoint","endPoint","currentPoint","MAZE_EMPTY","point","type","getFieldPointType","MAZE_WALL","distance","checkFunction","neighbourPoints","points","push","step","setFieldPointType","getCurrentPoint","MAZE_WAY","getNeighboursPoints","MAZE_PATH","length","move","nextPoint","setCurrentPoint","canvas","document","getElementById","mazeBacktrackingGenerator","BacktrackingGenerator","mazeCanvasRender","CanvasRenderer","window","super","checkFieldSize","Error","genInitField","generate","returnCount","count","unvisitedPoints","MAZE_POINT_VISITED","getUnvisitedPointsEx","pointFrom","pointTo","xDiff","yDiff","target","Math","abs","issetEndPoint","getStartPoint","pathStack","unvisitedPointsCount","getUnvisitedPointsCount","randomInt","removeWall","setEndPoint","pathStackPoint","pop","undefined","getUnvisitedPoints","randNum","min","max","floor","random","maze","pointSize","colorBorder","colorPath","colorWay","colorStartPoint","colorEndPoint","colorCurrentPoint","getWidth","getHeight","ctx","getContext","fillStyle","fillRect","isCurrentPoint","isStartPoint","isEndPoint"],"mappings":"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","file":"web-bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\n * Class Point\n */\nclass Point {\n  public x: number;\n  public y: number;\n\n  /**\n   * Constructor\n   * @param {int} x\n   * @param {int} y\n   */\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nexport {Point};\n","import {Point} from './point';\n\n/**\n * Class Maze\n */\nclass Maze {\n  static readonly MAZE_EMPTY = 0;\n  static readonly MAZE_WALL = 1;\n  static readonly MAZE_PATH = 2;\n  static readonly MAZE_WAY = 3;\n\n  protected width!: number;\n  protected height!: number;\n  protected field!: number[][];\n  protected startPoint!: Point;\n  protected currentPoint!: Point;\n  protected endPoint!: Point;\n\n  /**\n   * Constructor\n   * @param {number} width\n   * @param {number} height\n   */\n  constructor(width = 0, height = 0) {\n    this.reInit(width, height);\n  }\n\n  /**\n   * reInit\n   * @param {number} width\n   * @param {number} height\n   */\n  public reInit(width: number, height: number): void {\n    this.width = width;\n    this.height = height;\n    this.field = this.genEmptyField();\n    this.startPoint = new Point(1, 1);\n    this.endPoint = new Point(1, 1);\n    this.currentPoint = new Point(1, 1);\n  }\n\n  /**\n   * getWidth\n   * @return {Point} width\n   */\n  public getWidth(): number {\n    return this.width;\n  }\n\n  /**\n   * getHeight\n   * @return {Point} width\n   */\n  public getHeight(): number {\n    return this.height;\n  }\n\n  /**\n   * getField\n   * @return {[][]} field\n   */\n  public getField(): number[][] {\n    return this.field;\n  }\n\n  /**\n   * genEmptyField\n   * @return {[][]} field\n   */\n  protected genEmptyField(): number[][] {\n    const field: number[][] = [];\n    for (let y = 0; y < this.height; y++) {\n      field[y] = [];\n      for (let x = 0; x < this.width; x++) {\n        field[y][x] = Maze.MAZE_EMPTY;\n      }\n    }\n    return field;\n  }\n\n  /**\n   * getFieldPointType\n   * @param {Point} point\n   * @return {number}\n   */\n  public getFieldPointType(point: Point): number {\n    return this.field[point.y][point.x];\n  }\n\n  /**\n   * setFieldPointType\n   * @param {Point} point\n   * @param {number} type\n   */\n  public setFieldPointType(point: Point, type: number): void {\n    this.field[point.y][point.x] = type;\n  }\n\n  /**\n   * getStartPoint\n   * @return {Point} startPoint\n   */\n  public getStartPoint(): Point {\n    return this.startPoint;\n  }\n\n  /**\n   * isStartPoint\n   * @param {Point} point\n   * @return {boolean}\n   */\n  public isStartPoint(point: Point): boolean {\n    return point.x === this.startPoint.x && point.y === this.startPoint.y;\n  }\n\n  /**\n   * getEndPoint\n   * @return {Point} endPoint\n   */\n  public getEndPoint(): Point {\n    return this.endPoint;\n  }\n\n  /**\n   * setEndPoint\n   * @param {Point} point\n   * @return {boolean}\n   */\n  public setEndPoint(point: Point): boolean {\n    const type = this.getFieldPointType(point);\n    if (type != Maze.MAZE_WALL) {\n      this.endPoint = point;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * isEndPoint\n   * @param {Point} point\n   * @return {boolean}\n   */\n  public isEndPoint(point: Point): boolean {\n    return point.x === this.endPoint.x && point.y === this.endPoint.y;\n  }\n\n  /**\n   * getCurrentPoint\n   * @return {Point} currentPoint\n   */\n  public getCurrentPoint(): Point {\n    return this.currentPoint;\n  }\n\n  /**\n   * setCurrentPoint\n   * @param {Point} point\n   * @return {boolean}\n   */\n  public setCurrentPoint(point: Point): boolean {\n    const type = this.getFieldPointType(point);\n    if (type != Maze.MAZE_WALL) {\n      this.currentPoint = point;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * isCurrentPoint\n   * @param {Point} point\n   * @return {boolean}\n   */\n  public isCurrentPoint(point: Point): boolean {\n    return point.x === this.currentPoint.x && point.y === this.currentPoint.y;\n  }\n\n  /**\n   * getNeighboursPoints\n   * @param {Point} point\n   * @param {number} distance\n   * @param {Function} checkFunction\n   * @return {Point[]}\n   */\n  protected getNeighboursPoints(point: Point, distance: number,\n      checkFunction: (type: number) => boolean): Point[] {\n    const neighbourPoints: Point[] = [];\n    const points: Point[] = [];\n    points[0] = new Point(point.x, point.y - distance);\n    points[1] = new Point(point.x + distance, point.y);\n    points[2] = new Point(point.x, point.y + distance);\n    points[3] = new Point(point.x - distance, point.y);\n\n    for (let i = 0; i < 4; i++) {\n      if (points[i].x > 0 && points[i].x < this.width - 1 &&\n        points[i].y > 0 && points[i].y < this.height - 1) {\n        const type = this.getFieldPointType(points[i]);\n        if (checkFunction(type)) {\n          neighbourPoints.push(points[i]);\n        }\n      }\n    }\n    return neighbourPoints;\n  }\n\n  /**\n   * move\n   * @param {Function} step\n   */\n  public move(step: () => boolean): void {\n    while (step()) {\n      this.setFieldPointType(this.getCurrentPoint(), Maze.MAZE_WAY);\n      const neighbourPoints =\n        this.getNeighboursPoints(this.getCurrentPoint(), 1,\n            (type) => {\n              return type === Maze.MAZE_PATH || type === Maze.MAZE_WAY;\n            });\n      if (neighbourPoints.length > 2) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * moveLeft\n   * @return {void}\n   */\n  public moveLeft(): void {\n    this.move(() => {\n      const nextPoint: Point =\n        new Point(this.currentPoint.x - 1, this.currentPoint.y);\n      return this.setCurrentPoint(nextPoint);\n    });\n  }\n\n  /**\n   * moveRight\n   * @return {void}\n   */\n  public moveRight(): void {\n    this.move(() => {\n      const nextPoint: Point =\n        new Point(this.currentPoint.x + 1, this.currentPoint.y);\n      return this.setCurrentPoint(nextPoint);\n    });\n  }\n\n  /**\n   * moveUp\n   * @return {void}\n   */\n  public moveUp(): void {\n    this.move(() => {\n      const nextPoint: Point =\n        new Point(this.currentPoint.x, this.currentPoint.y - 1);\n      return this.setCurrentPoint(nextPoint);\n    });\n  }\n\n  /**\n   * moveDown\n   * @return {void}\n   */\n  public moveDown(): void {\n    this.move(() => {\n      const nextPoint: Point =\n        new Point(this.currentPoint.x, this.currentPoint.y + 1);\n      return this.setCurrentPoint(nextPoint);\n    });\n  }\n}\n\nexport {Maze};\n","import {BacktrackingGenerator} from './generators/backtracking';\nimport {CanvasRenderer} from './renderers/canvas';\n\nconst canvas = <HTMLCanvasElement>document.getElementById(\"canvas\");\n\nconst mazeBacktrackingGenerator = new BacktrackingGenerator(41, 41);\nconst mazeCanvasRender = new CanvasRenderer(mazeBacktrackingGenerator, canvas,20);\n\ndeclare global {\n  interface Window {\n    mazeBacktrackingGenerator: BacktrackingGenerator;\n    mazeCanvasRender: CanvasRenderer;\n  }\n}\nwindow.mazeBacktrackingGenerator = mazeBacktrackingGenerator;\nwindow.mazeCanvasRender = mazeCanvasRender;\n","import {Maze} from '../maze';\nimport {Point} from '../point';\n\n/**\n * Class BacktrackingGenerator\n */\nclass BacktrackingGenerator extends Maze {\n  static readonly MAZE_POINT_VISITED = 10;\n  private distance!: number;\n\n  /**\n   * Constructor\n   * @param {number} width\n   * @param {number} height\n   * @param {number} distance\n   */\n  constructor(width: number, height: number, distance = 2) {\n    super(width, height);\n    this.reInit(width, height, distance);\n  }\n\n  /**\n   * reInit\n   * @param {number} width\n   * @param {number} height\n   * @param {number} distance\n   */\n  public reInit(width: number, height: number, distance = 2): void {\n    super.reInit(width, height);\n    if (BacktrackingGenerator.checkFieldSize(width, height)) {\n      throw new Error('Field width and height MUST be odd');\n    }\n    this.field = this.genInitField();\n    this.distance = distance;\n    this.generate();\n  }\n\n  /**\n   * genInitField\n   * @return {[][]} field\n   */\n  private genInitField(): number[][] {\n    const field: number[][] = [];\n    for (let y = 0; y < this.height; y++) {\n      field[y] = [];\n      for (let x = 0; x < this.width; x++) {\n        if (x % 2 && y % 2) {\n          field[y][x] = Maze.MAZE_EMPTY;\n        } else {\n          field[y][x] = Maze.MAZE_WALL;\n        }\n      }\n    }\n    return field;\n  }\n\n  /**\n   * getUnvisitedPointsEx\n   * @param {boolean} returnCount\n   * @return {Point[]|number}\n   */\n  private getUnvisitedPointsEx(returnCount = true): Point[] | number {\n    let count = 0;\n    const unvisitedPoints: Point[] = [];\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        const point = new Point(x, y);\n        const type = this.getFieldPointType(point);\n        if (type !== Maze.MAZE_WALL &&\n          type !== BacktrackingGenerator.MAZE_POINT_VISITED) {\n          count++;\n          unvisitedPoints.push(point);\n        }\n      }\n    }\n    return returnCount ? count : unvisitedPoints;\n  }\n\n  /**\n   * getUnvisitedPointsCount\n   * @return {number}\n   */\n  private getUnvisitedPointsCount(): number {\n    return <number> this.getUnvisitedPointsEx();\n  }\n\n  /**\n   * getUnvisitedPoints\n   * @return {Point[]}\n   */\n  private getUnvisitedPoints(): Point[] {\n    return <Point[]> this.getUnvisitedPointsEx(false);\n  }\n\n  /**\n   * removeWall\n   * @param {Point} pointFrom\n   * @param {Point} pointTo\n   */\n  private removeWall(pointFrom: Point, pointTo: Point): void {\n    const xDiff = pointTo.x - pointFrom.x;\n    const yDiff = pointTo.y - pointFrom.y;\n    const target = new Point(\n        pointFrom.x + ((xDiff !== 0) ? (xDiff / Math.abs(xDiff)) : 0),\n        pointFrom.y + ((yDiff !== 0) ? (yDiff / Math.abs(yDiff)) : 0),\n    );\n    this.setFieldPointType(target, BacktrackingGenerator.MAZE_POINT_VISITED);\n  }\n\n  /**\n   * generate\n   */\n  private generate(): void {\n    let issetEndPoint = false;\n    let neighbourPoints: Point[] = [];\n    let currentPoint = this.getStartPoint();\n    const pathStack: Point[] = [];\n    pathStack.push(currentPoint);\n    this.setFieldPointType(currentPoint,\n        BacktrackingGenerator.MAZE_POINT_VISITED);\n\n    let unvisitedPointsCount = this.getUnvisitedPointsCount();\n    while (unvisitedPointsCount > 0) {\n      neighbourPoints =\n        this.getNeighboursPoints(currentPoint, this.distance,\n            (type: number) => {\n              return type !== Maze.MAZE_WALL &&\n              type !== Maze.MAZE_PATH &&\n              type !== Maze.MAZE_WAY &&\n              type !== BacktrackingGenerator.MAZE_POINT_VISITED;\n            });\n\n      if (neighbourPoints.length !== 0) {\n        const randNum =\n          BacktrackingGenerator.randomInt(0, neighbourPoints.length - 1);\n        const nextPoint = neighbourPoints[randNum];\n        this.removeWall(currentPoint, nextPoint);\n        currentPoint = nextPoint;\n        pathStack.push(currentPoint);\n        this.setFieldPointType(currentPoint,\n            BacktrackingGenerator.MAZE_POINT_VISITED);\n        unvisitedPointsCount--;\n        if (!issetEndPoint && unvisitedPointsCount === 0) {\n          issetEndPoint = this.setEndPoint(currentPoint);\n        }\n      } else if (pathStack.length > 0) {\n        const pathStackPoint = pathStack.pop();\n        if (pathStackPoint !== undefined) {\n          currentPoint = pathStackPoint;\n          if (!issetEndPoint) {\n            issetEndPoint = this.setEndPoint(currentPoint);\n          }\n        }\n      } else {\n        const unvisitedPoints = this.getUnvisitedPoints();\n        const randNum =\n          BacktrackingGenerator.randomInt(0, unvisitedPoints.length - 1);\n        currentPoint = unvisitedPoints[randNum];\n      }\n    }\n\n    for (let x = 0; x < this.width; x++) {\n      for (let y = 0; y < this.height; y++) {\n        const point = new Point(x, y);\n        const type = this.getFieldPointType(point);\n        if (type === BacktrackingGenerator.MAZE_POINT_VISITED) {\n          this.setFieldPointType(point, Maze.MAZE_PATH);\n        }\n      }\n    }\n\n    const point = new Point(this.width - 2, this.height - 2);\n    if (this.getFieldPointType(point) !== Maze.MAZE_PATH) {\n      neighbourPoints =\n        this.getNeighboursPoints(point, 1,\n            (type: number) => {\n              return type === Maze.MAZE_PATH;\n            });\n      if (neighbourPoints.length !== 0) {\n        const randNum =\n          BacktrackingGenerator.randomInt(0, neighbourPoints.length - 1);\n        this.setEndPoint(neighbourPoints[randNum]);\n      }\n    } else {\n      this.setEndPoint(point);\n    }\n  }\n\n  /**\n   * randomInteger\n   * @param {number} min\n   * @param {number} max\n   * @return {number}\n   */\n  public static randomInt(min: number, max: number): number {\n    return Math.floor(min + Math.random() * (max + 1 - min));\n  }\n\n  /**\n   * checkFieldSize\n   * @param {number} width\n   * @param {number} height\n   * @return {boolean}\n   */\n  private static checkFieldSize(width: number, height: number): boolean {\n    return (width - 1) % 2 !== 0 || (height - 1) % 2 !== 0;\n  }\n}\n\nexport {BacktrackingGenerator};\n","import {Maze} from '../maze';\nimport {Point} from '../point';\n\n/**\n * Class CanvasRenderer\n */\nclass CanvasRenderer {\n  private maze: Maze;\n  private canvas: HTMLCanvasElement;\n  private readonly pointSize: number;\n  private readonly colorBorder: string;\n  private readonly colorPath: string;\n  private readonly colorWay: string;\n  private readonly colorStartPoint: string;\n  private readonly colorEndPoint: string;\n  private readonly colorCurrentPoint: string;\n\n  /**\n   * Constructor\n   * @param {Maze} maze\n   * @param {HTMLCanvasElement} canvas\n   * @param {number} pointSize\n   * @param {string} colorBorder\n   * @param {string} colorPath\n   * @param {string} colorWay\n   * @param {string} colorStartPoint\n   * @param {string} colorEndPoint\n   * @param {string} colorCurrentPoint\n   */\n  constructor(maze: Maze, canvas: HTMLCanvasElement,\n      pointSize: number,\n      colorBorder = '#032B43',\n      colorPath = '#3F88C5',\n      colorWay = '#F19953',\n      colorStartPoint = '#136F63',\n      colorEndPoint = '#FFBA08',\n      colorCurrentPoint = '#D00000',\n  ) {\n    this.pointSize = pointSize;\n    this.colorBorder = colorBorder;\n    this.colorPath = colorPath;\n    this.colorWay = colorWay;\n    this.colorStartPoint = colorStartPoint;\n    this.colorEndPoint = colorEndPoint;\n    this.colorCurrentPoint = colorCurrentPoint;\n\n    this.maze = maze;\n    this.canvas = canvas;\n    canvas.width = this.pointSize * this.maze.getWidth();\n    canvas.height = this.pointSize * this.maze.getHeight();\n  }\n\n  /**\n   * render\n   */\n  public render(): void {\n    const ctx = this.canvas.getContext('2d');\n    if (ctx !== null) {\n      ctx.fillStyle = this.colorBorder;\n      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n      for (let y = 0; y < this.maze.getHeight(); y++) {\n        for (let x = 0; x < this.maze.getWidth(); x++) {\n          const point = new Point(x, y);\n          const type = this.maze.getFieldPointType(point);\n\n          if (this.maze.isCurrentPoint(point)) {\n            ctx.fillStyle = this.colorCurrentPoint;\n          } else if (this.maze.isStartPoint(point)) {\n            ctx.fillStyle = this.colorStartPoint;\n          } else if (this.maze.isEndPoint(point)) {\n            ctx.fillStyle = this.colorEndPoint;\n          } else if (type === Maze.MAZE_PATH) {\n            ctx.fillStyle = this.colorPath;\n          } else if (type === Maze.MAZE_WAY) {\n            ctx.fillStyle = this.colorWay;\n          }\n          if (type !== Maze.MAZE_WALL) {\n            ctx.fillRect(this.pointSize * x, this.pointSize * y,\n                this.pointSize, this.pointSize);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport {CanvasRenderer};\n"],"sourceRoot":""}