!function(t){var e={};function i(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return t[n].call(o.exports,o,o.exports,i),o.l=!0,o.exports}i.m=t,i.c=e,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)i.d(n,o,function(e){return t[e]}.bind(null,o));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=2)}([function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Point=void 0;e.Point=class{constructor(t,e){this.x=t,this.y=e}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Maze=void 0;const n=i(0);class o{constructor(t=0,e=0){this.reInit(t,e)}reInit(t,e){this.width=t,this.height=e,this.field=this.genEmptyField(),this.startPoint=new n.Point(1,1),this.endPoint=new n.Point(1,1),this.currentPoint=new n.Point(1,1)}getWidth(){return this.width}getHeight(){return this.height}getField(){return this.field}genEmptyField(){const t=[];for(let e=0;e<this.height;e++){t[e]=[];for(let i=0;i<this.width;i++)t[e][i]=o.MAZE_EMPTY}return t}getFieldPointType(t){return this.field[t.y][t.x]}setFieldPointType(t,e){this.field[t.y][t.x]=e}getStartPoint(){return this.startPoint}isStartPoint(t){return t.x===this.startPoint.x&&t.y===this.startPoint.y}getEndPoint(){return this.endPoint}setEndPoint(t){return this.getFieldPointType(t)!=o.MAZE_WALL&&(this.endPoint=t,!0)}isEndPoint(t){return t.x===this.endPoint.x&&t.y===this.endPoint.y}getCurrentPoint(){return this.currentPoint}setCurrentPoint(t){return this.getFieldPointType(t)!=o.MAZE_WALL&&(this.currentPoint=t,!0)}isCurrentPoint(t){return t.x===this.currentPoint.x&&t.y===this.currentPoint.y}getNeighboursPoints(t,e,i){const o=[],r=[];r[0]=new n.Point(t.x,t.y-e),r[1]=new n.Point(t.x+e,t.y),r[2]=new n.Point(t.x,t.y+e),r[3]=new n.Point(t.x-e,t.y);for(let t=0;t<4;t++)if(r[t].x>0&&r[t].x<this.width-1&&r[t].y>0&&r[t].y<this.height-1){i(this.getFieldPointType(r[t]))&&o.push(r[t])}return o}move(t){for(;t();){this.setFieldPointType(this.getCurrentPoint(),o.MAZE_WAY);if(this.getNeighboursPoints(this.getCurrentPoint(),1,t=>t===o.MAZE_PATH||t===o.MAZE_WAY).length>2)break}}moveLeft(){this.move(()=>{const t=new n.Point(this.currentPoint.x-1,this.currentPoint.y);return this.setCurrentPoint(t)})}moveRight(){this.move(()=>{const t=new n.Point(this.currentPoint.x+1,this.currentPoint.y);return this.setCurrentPoint(t)})}moveUp(){this.move(()=>{const t=new n.Point(this.currentPoint.x,this.currentPoint.y-1);return this.setCurrentPoint(t)})}moveDown(){this.move(()=>{const t=new n.Point(this.currentPoint.x,this.currentPoint.y+1);return this.setCurrentPoint(t)})}}e.Maze=o,o.MAZE_EMPTY=0,o.MAZE_WALL=1,o.MAZE_PATH=2,o.MAZE_WAY=3},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=i(3),o=i(4),r=document.getElementById("canvas"),s=new n.BacktrackingGenerator(41,41),h=new o.CanvasRenderer(s,r,20);window.mazeBacktrackingGenerator=s,window.mazeCanvasRender=h},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.BacktrackingGenerator=void 0;const n=i(1),o=i(0);class r extends n.Maze{constructor(t,e,i=2){super(t,e),this.reInit(t,e,i)}reInit(t,e,i=2){if(super.reInit(t,e),r.checkFieldSize(t,e))throw new Error("Field width and height MUST be odd");this.field=this.genInitField(),this.distance=i,this.generate()}genInitField(){const t=[];for(let e=0;e<this.height;e++){t[e]=[];for(let i=0;i<this.width;i++)t[e][i]=i%2&&e%2?n.Maze.MAZE_EMPTY:n.Maze.MAZE_WALL}return t}getUnvisitedPointsEx(t=!0){let e=0;const i=[];for(let t=0;t<this.width;t++)for(let s=0;s<this.height;s++){const h=new o.Point(t,s),l=this.getFieldPointType(h);l!==n.Maze.MAZE_WALL&&l!==r.MAZE_POINT_VISITED&&(e++,i.push(h))}return t?e:i}getUnvisitedPointsCount(){return this.getUnvisitedPointsEx()}getUnvisitedPoints(){return this.getUnvisitedPointsEx(!1)}removeWall(t,e){const i=e.x-t.x,n=e.y-t.y,s=new o.Point(t.x+(0!==i?i/Math.abs(i):0),t.y+(0!==n?n/Math.abs(n):0));this.setFieldPointType(s,r.MAZE_POINT_VISITED)}generate(){let t=!1,e=[],i=this.getStartPoint();const s=[];s.push(i),this.setFieldPointType(i,r.MAZE_POINT_VISITED);let h=this.getUnvisitedPointsCount();for(;h>0;)if(e=this.getNeighboursPoints(i,this.distance,t=>t!==n.Maze.MAZE_WALL&&t!==n.Maze.MAZE_PATH&&t!==n.Maze.MAZE_WAY&&t!==r.MAZE_POINT_VISITED),0!==e.length){const n=e[r.randomInt(0,e.length-1)];this.removeWall(i,n),i=n,s.push(i),this.setFieldPointType(i,r.MAZE_POINT_VISITED),h--,t||0!==h||(t=this.setEndPoint(i))}else if(s.length>0){const e=s.pop();void 0!==e&&(i=e,t||(t=this.setEndPoint(i)))}else{const t=this.getUnvisitedPoints();i=t[r.randomInt(0,t.length-1)]}for(let t=0;t<this.width;t++)for(let e=0;e<this.height;e++){const i=new o.Point(t,e);this.getFieldPointType(i)===r.MAZE_POINT_VISITED&&this.setFieldPointType(i,n.Maze.MAZE_PATH)}const l=new o.Point(this.width-2,this.height-2);if(this.getFieldPointType(l)!==n.Maze.MAZE_PATH){if(e=this.getNeighboursPoints(l,1,t=>t===n.Maze.MAZE_PATH),0!==e.length){const t=r.randomInt(0,e.length-1);this.setEndPoint(e[t])}}else this.setEndPoint(l)}static randomInt(t,e){return Math.floor(t+Math.random()*(e+1-t))}static checkFieldSize(t,e){return(t-1)%2!=0||(e-1)%2!=0}}e.BacktrackingGenerator=r,r.MAZE_POINT_VISITED=10},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CanvasRenderer=void 0;const n=i(1),o=i(0);e.CanvasRenderer=class{constructor(t,e,i,n="#032B43",o="#3F88C5",r="#F19953",s="#136F63",h="#FFBA08",l="#D00000"){this.pointSize=i,this.colorBorder=n,this.colorPath=o,this.colorWay=r,this.colorStartPoint=s,this.colorEndPoint=h,this.colorCurrentPoint=l,this.maze=t,this.canvas=e,e.width=this.pointSize*this.maze.getWidth(),e.height=this.pointSize*this.maze.getHeight()}render(){const t=this.canvas.getContext("2d");if(null!==t){t.fillStyle=this.colorBorder,t.fillRect(0,0,this.canvas.width,this.canvas.height);for(let e=0;e<this.maze.getHeight();e++)for(let i=0;i<this.maze.getWidth();i++){const r=new o.Point(i,e),s=this.maze.getFieldPointType(r);this.maze.isCurrentPoint(r)?t.fillStyle=this.colorCurrentPoint:this.maze.isStartPoint(r)?t.fillStyle=this.colorStartPoint:this.maze.isEndPoint(r)?t.fillStyle=this.colorEndPoint:s===n.Maze.MAZE_PATH?t.fillStyle=this.colorPath:s===n.Maze.MAZE_WAY&&(t.fillStyle=this.colorWay),s!==n.Maze.MAZE_WALL&&t.fillRect(this.pointSize*i,this.pointSize*e,this.pointSize,this.pointSize)}}}}}]);
//# sourceMappingURL=web-bundle.js.map